{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 06c5a1abab5829c30456","webpack:///../src/index.js","webpack:///../src/history/hash.js","webpack:///../src/util.js","webpack:///../~/route-recognizer/dist/route-recognizer.js","webpack:///../~/webpack/buildin/module.js","webpack:///../~/webpack/buildin/amd-define.js","webpack:///../src/history/abstract.js","webpack:///../src/history/html5.js","webpack:///../src/component/router-view/main.js","webpack:///../src/route.js","webpack:///../src/transition.js","webpack:///../src/pipeline.js"],"names":[],"mappings":"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;AACzE;AACA;AACA,kCAAiC,yDAAyD;AAC1F,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA,qDAAoD,kBAAkB;AACtE;AACA;AACA,kCAAiC,wDAAwD;AACzF,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,0BAAyB,WAAW,EAAE;AACtC,6BAA4B,WAAW;AACvC;;AAEA;AACA;AACA;AACA,qCAAoC,yBAAyB;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,qBAAqB;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA,0CAAyC,cAAc;;AAEvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,qBAAqB;AAC1C;;AAEA;;AAEA;AACA,4CAA2C,sBAAsB;AACjE,YAAW;AACX,4CAA2C,sBAAsB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA,qCAAoC,KAAK;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,mBAAmB;AACtC;;AAEA,sBAAqB,gBAAgB;AACrC;AACA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,eAAe;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6BAA4B;AAC5B;;AAEA;;AAEA,sBAAqB,iBAAiB;AACtC;;AAEA;;AAEA;;AAEA,wBAAuB,mBAAmB;AAC1C;;AAEA,yEAAwE,UAAU;;AAElF;;AAEA;AACA,8CAA6C,0DAA0D;AACvG;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA,4CAA2C,0DAA0D;AACrG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA,sBAAqB,oDAAoD;;AAEzE;;AAEA,sBAAqB,yBAAyB;AAC9C;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,sBAAqB,oDAAoD;;AAEzE;;AAEA,sBAAqB,mBAAmB;AACxC;;AAEA,uEAAsE,UAAU;;AAEhF;AACA;AACA;;AAEA,wCAAuC,uBAAuB;;AAE9D;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA,kCAAiC,WAAW;;AAE5C;AACA,QAAO;;AAEP;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;A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","file":"nova-router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NovaRouter\"] = factory();\n\telse\n\t\troot[\"NovaRouter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 06c5a1abab5829c30456\n **/","import HashHistory from './history/hash'\nimport AbstractHistory from './history/abstract'\nimport HTML5History from './history/html5'\nimport './component/router-view/main.js'\nimport RouteRecognizer from 'route-recognizer'\nimport Route from './route.js'\nimport Transition from './transition.js'\nimport {inBrowser, warn, mapParams,isObject } from './util'\n\nconst historyBackends = {\n    abstract: AbstractHistory,\n    hash: HashHistory,\n    html5: HTML5History\n}\n\nexport default class Router {\n    constructor ({\n        hashbang = true,\n        abstract = false,\n        history = false,\n        saveScrollPosition = false, //used in history\n        suppressTransitionError = false,\n        root = null,\n    } = {}) {\n        // route recognizer\n        this._recognizer = new RouteRecognizer();\n\n        // state\n        this._started = false\n        this._startCb = null\n        this._currentRoute = {}\n        this._currentTransition = null\n        this._previousTransition = null\n        this._notFoundHandler = null\n        this._notFoundRedirect = null\n        this._beforeEachHooks = []\n        this._afterEachHooks = []\n        this._rendered = false\n\n        // history mode\n        this._root = root\n        this._hashbang = hashbang\n        this._abstract = abstract\n\n        // check if HTML5 histroy is available\n        const hasPushState = \n            typeof window !== 'undefined' && window.history && window.history.pushState\n        this._history = history && hasPushState\n        this._historyFallBack = history && !hasPushState\n\n        // create history object\n        this.mode = (!inBrowser || this._abstract)\n            ? 'abstract'\n            : this._history\n                ? 'html5'\n                : 'hash'\n        const History = historyBackends[this.mode];\n        this.history = new History({\n            root:root,\n            hashbang:this._hashbang,\n            onChange:(path,state,anchor) =>{\n                this._match(path,state,anchor)\n            }\n        });\n\n        this._suppress = suppressTransitionError\n        this._components = []\n    }\n\n    // API ===================================================\n    /**\n     * register the map\n     * @param  {[type]} map [description]\n     * @return {[type]}     [description]\n     */\n    map (map) {\n        for(let route in map){\n            this.on(route,map[route])\n        }\n        return this\n    }\n\n    /**\n     * register each route\n     * @param  {[type]} rootPath [description]\n     * @param  {[type]} handler  [description]\n     * @return {[type]}          [description]\n     */\n    on (rootPath,handler){\n        if(rootPath === '*'){\n            this._notFound(handler)\n        } else {\n            this._addRoute(rootPath,handler,[])\n        }\n        return this;\n    }\n\n    /**\n     * set global before hook\n     * @param  {Function} fn [description]\n     * @return {[type]}      [description]\n     */\n    beforeEach (fn) {\n        this._beforeEachHooks.push(fn)\n        return this;\n    }\n\n    /**\n     * set global after hook\n     * @param  {Function} fn [description]\n     * @return {[type]}      [description]\n     */\n    afterEach (fn){\n        this._afterEachHooks.push(fn)\n        return this;\n    }\n\n    /**\n     * go to a new path\n     * @param  {[type]} path [description]\n     * @return {[type]}      [description]\n     */\n    go (path){\n        let replace = false;\n        let append = false;\n        if(isObject(path)){\n            replace = path.replace\n            append = path.append\n        }\n        path = this.stringifyPath(path)\n        if(path){\n            this.history.go(path,replace,append)\n        }\n    }\n\n    /**\n     * replace current path\n     * @param  {[type]} path [description]\n     * @return {[type]}      [description]\n     */\n    replace (path) {\n        if (typeof path === \"string\"){\n            path = {path}\n        }\n        path.replace = true;\n        this.go(path)\n    }\n\n    /**\n     * 启动路由\n     * @param  {[type]}   router [description]\n     * @param  {Function} cb     [description]\n     * @return {[type]}          [description]\n     */\n    start (routerView, cb){\n        if(this._started){\n            warn(\"already started.\")\n            return\n        }\n        if(!this.routerView){\n            if(!routerView){\n                throw new Error(\"Must start router with router view\")\n                return\n            }\n        }\n        if(typeof routerView === 'string') {\n            routerView = document.querySelector(routerView)\n        }\n        this.routerView = routerView\n        this._components.unshift(routerView)\n        this._started = true\n        this._startCb = cb\n        this.history.start()\n    }\n\n    /**\n     * Stop listening to route changes.\n     */\n\n    stop () {\n        this.history.stop()\n        this._started = false\n    }\n\n    /**\n     * normalize named route object into string\n     * @param  {[type]} path [description]\n     * @return {[type]}      [description]\n     */\n    stringifyPath (path) {\n        let generatePath = ''\n        if(path && typeof path === 'object'){\n            if(path.name) { \n                // 具名路径\n                generatePath = encodeURI(this._recognizer.generate(path.name, path.params || {}))\n            } else if(path.path){\n                generatePath = encodeURI(path.path)\n            }\n            if(path.query){\n                const query = this._recognizer.generateQueryString(path.query)\n                if(generatePath.indexOf('?') > -1){\n                    generatePath += '&'+query.slice(1);\n                } else {\n                    generatePath += query\n                }\n            }\n        } else {\n            generatePath = encodeURI(path?path+'':'')\n        }\n        return generatePath\n    }\n\n    // Internal methods ======================================\n    /**\n     * set the not found router handler\n     * @param  {[type]} handler [description]\n     * @return {[type]}         [description]\n     */\n    _notFound (handler) {\n        this._notFoundHandler = [{ handler: handler }]\n    }\n\n    /**\n     * add route and at the same time add the subroute\n     * @param {[type]} path     [description]\n     * @param {[type]} handler  [description]\n     * @param {[type]} segments [description]\n     */\n    _addRoute (path,handler,segments){\n        handler.path = path\n        handler.fullPath = (segments.reduce((path,segment)=>{\n            return path+segment.path\n        },'') + path)\n        segments.push({\n            path: path,\n            handler: handler\n        })\n        this._recognizer.add(segments,{\n            as:handler.name\n        })\n        if(handler.component && !this._components.includes(handler.component)){\n            this._components.push(handler.component)\n            handler.component.$route = this._currentRoute\n        }\n        // handle sub router\n        if(handler.subRoutes){\n            for (let subPath in handler.subRoutes){\n                // pass a copy of segments to avoid mutating\n                this._addRoute(subPath,handler.subRoutes[subPath],segments.slice())\n            }\n        }\n    }\n\n    /**\n     * match the url path and move to the correct view\n     * @param  {[type]} path   [description]\n     * @param  {[type]} state  [description]\n     * @param  {[type]} anchor [description]\n     * @return {[type]}        [description]\n     */\n    _match (path,state,anchor) {\n        // 这里有一个检查路径的操作\n        const currentRoute = this._currentRoute\n        const currentTransition = this._currentTransition\n\n        if(currentTransition){\n            if (currentTransition.to.path === path){\n                // we have an transition doing that thing so ignore the request\n                return\n            } else if(currentRoute.path === path) {\n                // we are going to the same place\n                // but that transition do not work well\n                // so we abort it and reset\n                currentTransition.aborted = true;\n                this._currentTransition = this._previousTransition\n                return\n            } else {\n                // we are going to different place so abort the current one\n                currentTransition.aborted = true\n            }\n        }\n\n        // construct an new route and the new transition\n        const route = new Route(path, this)\n        const transition = new Transition(this, route, currentRoute)\n\n        this._previousTransition = currentTransition\n        this._currentTransition = transition\n\n        const beforeHooks = this._beforeEachHooks\n        const startTransition = (()=>{\n            transition.start(()=>{\n                this._postTransition(transition)\n            })\n        })\n        if(beforeHooks.length) {\n            transition.callHooks(beforeHooks,null,startTransition,{expectBoolean:true})\n        } else {\n            startTransition()\n        }\n    }\n\n    /**\n     * called when we validate the transition can run\n     * @param  {[type]} transition [description]\n     * @return {[type]}            [description]\n     */\n    _onTransitionValidated (transition) {\n        this._currentRoute = transition.to\n        // copy one in case of the user change our route\n        const route = Object.assign({},this._currentRoute)\n        this._components.forEach(each=>{\n            each.$route = route;\n        })\n    }\n\n    /**\n     * called when we finished transition\n     * @return {[type]} [description]\n     */\n    _postTransition(transition){\n        // the first time catch change we call the started callback\n        if (!this._rendered && this._startCb) {\n            this._rendered = true\n            this._startCb.call(null)\n        }\n        this._currentTransition.done = true\n        if(this._afterEachHooks.length) {\n            this._afterEachHooks.forEach(hook =>hook.call(null,{\n                to:transition.to,\n                from:transition.from\n            }))\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/index.js\n **/","import { resolvePath } from '../util'\nexport default class HashHistory {\n    constructor ({hashbang,onChange}) {\n        this.hashbang = hashbang\n        this.onChange = onChange\n    }\n\n    start () {\n        const self = this;\n        this.listener = function () {\n            const path = location.hash\n            let raw = path.replace(/^#!?/,'')\n            if(raw.charAt(0) !== '/'){\n                raw = '/'+raw\n            }\n            const formattedPath = self.formatPath(raw);\n            if (formattedPath !== path) {\n                location.replace(formattedPath)\n                return\n            }\n            // 此处vue-router有一个将query拼接上去的步骤\n            // 没有搞懂为什么这么做\n            // 先不加上\n            // const query = location.search && path.indexOf('?') > -1\n            //   ? '&' + location.search.slice(1)\n            //   : location.search\n            self.onChange(path.replace(/^#!?/, ''));\n        }\n        // 监听hashchange\n        window.addEventListener('hashchange', this.listener)\n        this.listener()\n    }\n\n    stop () {\n        window.removeEventListener('hashchange', this.listener)\n    }\n\n    go (path, replace, append) {\n        path = this.formatPath(path, append)\n        if (replace) {\n            location.replace(path)\n        } else {\n            location.hash = path\n        }\n    }\n\n    /**\n     * format to absolute path\n     * 格式化为绝对路径\n     */\n    formatPath (path,append) {\n        const isAbsolute = path.charAt(0) === '/'\n        const prefix = '#' + (this.hashbang?'!':'')\n        return isAbsolute\n            ? prefix + path\n            : prefix + resolvePath(location.hash.replace(/^#!?/,''),path,append)\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/history/hash.js\n **/","import RouteRecognizer from 'route-recognizer'\nconst genQuery = RouteRecognizer.prototype.generateQueryString\n/**\n * Resolve a relative path.\n * 根据相对路径拼接出绝对路径\n *\n * @param {String} base\n * @param {String} relative\n * @param {Boolean} append ?是否要拼接\n * @return {String}\n */\nexport function resolvePath (base, relative, append) {\n  let query = base.match(/(\\?.*)$/)\n  if (query) {\n    query = query[1]\n    base = base.slice(0, -query.length)\n  }\n  // a query!\n  if (relative.charAt(0) === '?') {\n    return base + relative\n  }\n  const stack = base.split('/')\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop()\n  }\n  // resolve relative path\n  const segments = relative.replace(/^\\//, '').split('/')\n  for (let i = 0; i < segments.length; i++) {\n    let segment = segments[i]\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop()\n    } else {\n      stack.push(segment)\n    }\n  }\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('')\n  }\n  return stack.join('/')\n}\n\n/**\n * 判断是否是promise\n * @param  {[type]}  p [description]\n * @return {Boolean}   [description]\n */\nexport function isPromise (p) {\n  return p &&\n    typeof p.then === 'function'\n}\n\n/**\n * 判断是不是object\n * @param  {[type]}  val [description]\n * @return {Boolean}     [description]\n */\nexport function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n\n/**\n * 通用warn函数\n * @param  {[type]} msg [description]\n * @return {[type]}     [description]\n */\nexport function warn (msg) {\n  /* istanbul ignore next */\n  if (typeof console !== 'undefined') {\n    console.error('[nova-router] ' + msg)\n  }\n}\n\n\n/**\n * Map the dynamic segments in a path to params.\n * 将动态片段置换为相应数值\n *\n * @param {String} path\n * @param {Object} params\n * @param {Object} query\n */\n\nexport function mapParams (path, params = {}, query) {\n  path = path.replace(/:([^\\/]+)/g, (_, key) => {\n    const val = params[key]\n    /* istanbul ignore if */\n    if (!val) {\n      warn(\n        'param \"' + key + '\" not found when generating ' +\n        'path for \"' + path + '\" with params ' + JSON.stringify(params)\n      )\n    }\n    return val || ''\n  })\n  if (query) {\n    path += genQuery(query)\n  }\n  return path\n}\n\nexport function inBrowser () {\n    return Object.prototype.toString.call(window) === \"[object Window]\"\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/util.js\n **/","(function() {\n    \"use strict\";\n    function $$route$recognizer$dsl$$Target(path, matcher, delegate) {\n      this.path = path;\n      this.matcher = matcher;\n      this.delegate = delegate;\n    }\n\n    $$route$recognizer$dsl$$Target.prototype = {\n      to: function(target, callback) {\n        var delegate = this.delegate;\n\n        if (delegate && delegate.willAddRoute) {\n          target = delegate.willAddRoute(this.matcher.target, target);\n        }\n\n        this.matcher.add(this.path, target);\n\n        if (callback) {\n          if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n          this.matcher.addChild(this.path, target, callback, this.delegate);\n        }\n        return this;\n      }\n    };\n\n    function $$route$recognizer$dsl$$Matcher(target) {\n      this.routes = {};\n      this.children = {};\n      this.target = target;\n    }\n\n    $$route$recognizer$dsl$$Matcher.prototype = {\n      add: function(path, handler) {\n        this.routes[path] = handler;\n      },\n\n      addChild: function(path, target, callback, delegate) {\n        var matcher = new $$route$recognizer$dsl$$Matcher(target);\n        this.children[path] = matcher;\n\n        var match = $$route$recognizer$dsl$$generateMatch(path, matcher, delegate);\n\n        if (delegate && delegate.contextEntered) {\n          delegate.contextEntered(target, match);\n        }\n\n        callback(match);\n      }\n    };\n\n    function $$route$recognizer$dsl$$generateMatch(startingPath, matcher, delegate) {\n      return function(path, nestedCallback) {\n        var fullPath = startingPath + path;\n\n        if (nestedCallback) {\n          nestedCallback($$route$recognizer$dsl$$generateMatch(fullPath, matcher, delegate));\n        } else {\n          return new $$route$recognizer$dsl$$Target(startingPath + path, matcher, delegate);\n        }\n      };\n    }\n\n    function $$route$recognizer$dsl$$addRoute(routeArray, path, handler) {\n      var len = 0;\n      for (var i=0; i<routeArray.length; i++) {\n        len += routeArray[i].path.length;\n      }\n\n      path = path.substr(len);\n      var route = { path: path, handler: handler };\n      routeArray.push(route);\n    }\n\n    function $$route$recognizer$dsl$$eachRoute(baseRoute, matcher, callback, binding) {\n      var routes = matcher.routes;\n\n      for (var path in routes) {\n        if (routes.hasOwnProperty(path)) {\n          var routeArray = baseRoute.slice();\n          $$route$recognizer$dsl$$addRoute(routeArray, path, routes[path]);\n\n          if (matcher.children[path]) {\n            $$route$recognizer$dsl$$eachRoute(routeArray, matcher.children[path], callback, binding);\n          } else {\n            callback.call(binding, routeArray);\n          }\n        }\n      }\n    }\n\n    var $$route$recognizer$dsl$$default = function(callback, addRouteCallback) {\n      var matcher = new $$route$recognizer$dsl$$Matcher();\n\n      callback($$route$recognizer$dsl$$generateMatch(\"\", matcher, this.delegate));\n\n      $$route$recognizer$dsl$$eachRoute([], matcher, function(route) {\n        if (addRouteCallback) { addRouteCallback(this, route); }\n        else { this.add(route); }\n      }, this);\n    };\n\n    var $$route$recognizer$$specials = [\n      '/', '.', '*', '+', '?', '|',\n      '(', ')', '[', ']', '{', '}', '\\\\'\n    ];\n\n    var $$route$recognizer$$escapeRegex = new RegExp('(\\\\' + $$route$recognizer$$specials.join('|\\\\') + ')', 'g');\n\n    function $$route$recognizer$$isArray(test) {\n      return Object.prototype.toString.call(test) === \"[object Array]\";\n    }\n\n    // A Segment represents a segment in the original route description.\n    // Each Segment type provides an `eachChar` and `regex` method.\n    //\n    // The `eachChar` method invokes the callback with one or more character\n    // specifications. A character specification consumes one or more input\n    // characters.\n    //\n    // The `regex` method returns a regex fragment for the segment. If the\n    // segment is a dynamic of star segment, the regex fragment also includes\n    // a capture.\n    //\n    // A character specification contains:\n    //\n    // * `validChars`: a String with a list of all valid characters, or\n    // * `invalidChars`: a String with a list of all invalid characters\n    // * `repeat`: true if the character specification can repeat\n\n    function $$route$recognizer$$StaticSegment(string) { this.string = string; }\n    $$route$recognizer$$StaticSegment.prototype = {\n      eachChar: function(currentState) {\n        var string = this.string, ch;\n\n        for (var i=0; i<string.length; i++) {\n          ch = string.charAt(i);\n          currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: ch });\n        }\n\n        return currentState;\n      },\n\n      regex: function() {\n        return this.string.replace($$route$recognizer$$escapeRegex, '\\\\$1');\n      },\n\n      generate: function() {\n        return this.string;\n      }\n    };\n\n    function $$route$recognizer$$DynamicSegment(name) { this.name = name; }\n    $$route$recognizer$$DynamicSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState.put({ invalidChars: \"/\", repeat: true, validChars: undefined });\n      },\n\n      regex: function() {\n        return \"([^/]+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$StarSegment(name) { this.name = name; }\n    $$route$recognizer$$StarSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState.put({ invalidChars: \"\", repeat: true, validChars: undefined });\n      },\n\n      regex: function() {\n        return \"(.+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$EpsilonSegment() {}\n    $$route$recognizer$$EpsilonSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState;\n      },\n      regex: function() { return \"\"; },\n      generate: function() { return \"\"; }\n    };\n\n    function $$route$recognizer$$parse(route, names, specificity) {\n      // normalize route as not starting with a \"/\". Recognition will\n      // also normalize.\n      if (route.charAt(0) === \"/\") { route = route.substr(1); }\n\n      var segments = route.split(\"/\");\n      var results = new Array(segments.length);\n\n      // A routes has specificity determined by the order that its different segments\n      // appear in. This system mirrors how the magnitude of numbers written as strings\n      // works.\n      // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n      // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n      // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n      // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n      // leading symbol, \"1\".\n      // The rule is that symbols to the left carry more weight than symbols to the right\n      // when a number is written out as a string. In the above strings, the leading digit\n      // represents how many 100's are in the number, and it carries more weight than the middle\n      // number which represents how many 10's are in the number.\n      // This system of number magnitude works well for route specificity, too. A route written as\n      // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n      // `x`, irrespective of the other parts.\n      // Because of this similarity, we assign each type of segment a number value written as a\n      // string. We can find the specificity of compound routes by concatenating these strings\n      // together, from left to right. After we have looped through all of the segments,\n      // we convert the string to a number.\n      specificity.val = '';\n\n      for (var i=0; i<segments.length; i++) {\n        var segment = segments[i], match;\n\n        if (match = segment.match(/^:([^\\/]+)$/)) {\n          results[i] = new $$route$recognizer$$DynamicSegment(match[1]);\n          names.push(match[1]);\n          specificity.val += '3';\n        } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n          results[i] = new $$route$recognizer$$StarSegment(match[1]);\n          specificity.val += '1';\n          names.push(match[1]);\n        } else if(segment === \"\") {\n          results[i] = new $$route$recognizer$$EpsilonSegment();\n          specificity.val += '2';\n        } else {\n          results[i] = new $$route$recognizer$$StaticSegment(segment);\n          specificity.val += '4';\n        }\n      }\n\n      specificity.val = +specificity.val;\n\n      return results;\n    }\n\n    // A State has a character specification and (`charSpec`) and a list of possible\n    // subsequent states (`nextStates`).\n    //\n    // If a State is an accepting state, it will also have several additional\n    // properties:\n    //\n    // * `regex`: A regular expression that is used to extract parameters from paths\n    //   that reached this accepting state.\n    // * `handlers`: Information on how to convert the list of captures into calls\n    //   to registered handlers with the specified parameters\n    // * `types`: How many static, dynamic or star segments in this route. Used to\n    //   decide which route to use if multiple registered routes match a path.\n    //\n    // Currently, State is implemented naively by looping over `nextStates` and\n    // comparing a character specification against a character. A more efficient\n    // implementation would use a hash of keys pointing at one or more next states.\n\n    function $$route$recognizer$$State(charSpec) {\n      this.charSpec = charSpec;\n      this.nextStates = [];\n      this.charSpecs = {};\n      this.regex = undefined;\n      this.handlers = undefined;\n      this.specificity = undefined;\n    }\n\n    $$route$recognizer$$State.prototype = {\n      get: function(charSpec) {\n        if (this.charSpecs[charSpec.validChars]) {\n          return this.charSpecs[charSpec.validChars];\n        }\n\n        var nextStates = this.nextStates;\n\n        for (var i=0; i<nextStates.length; i++) {\n          var child = nextStates[i];\n\n          var isEqual = child.charSpec.validChars === charSpec.validChars;\n          isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n          if (isEqual) {\n            this.charSpecs[charSpec.validChars] = child;\n            return child;\n          }\n        }\n      },\n\n      put: function(charSpec) {\n        var state;\n\n        // If the character specification already exists in a child of the current\n        // state, just return that state.\n        if (state = this.get(charSpec)) { return state; }\n\n        // Make a new state for the character spec\n        state = new $$route$recognizer$$State(charSpec);\n\n        // Insert the new state as a child of the current state\n        this.nextStates.push(state);\n\n        // If this character specification repeats, insert the new state as a child\n        // of itself. Note that this will not trigger an infinite loop because each\n        // transition during recognition consumes a character.\n        if (charSpec.repeat) {\n          state.nextStates.push(state);\n        }\n\n        // Return the new state\n        return state;\n      },\n\n      // Find a list of child states matching the next character\n      match: function(ch) {\n        var nextStates = this.nextStates,\n            child, charSpec, chars;\n\n        var returned = [];\n\n        for (var i=0; i<nextStates.length; i++) {\n          child = nextStates[i];\n\n          charSpec = child.charSpec;\n\n          if (typeof (chars = charSpec.validChars) !== 'undefined') {\n            if (chars.indexOf(ch) !== -1) { returned.push(child); }\n          } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n            if (chars.indexOf(ch) === -1) { returned.push(child); }\n          }\n        }\n\n        return returned;\n      }\n    };\n\n    // Sort the routes by specificity\n    function $$route$recognizer$$sortSolutions(states) {\n      return states.sort(function(a, b) {\n        return b.specificity.val - a.specificity.val;\n      });\n    }\n\n    function $$route$recognizer$$recognizeChar(states, ch) {\n      var nextStates = [];\n\n      for (var i=0, l=states.length; i<l; i++) {\n        var state = states[i];\n\n        nextStates = nextStates.concat(state.match(ch));\n      }\n\n      return nextStates;\n    }\n\n    var $$route$recognizer$$oCreate = Object.create || function(proto) {\n      function F() {}\n      F.prototype = proto;\n      return new F();\n    };\n\n    function $$route$recognizer$$RecognizeResults(queryParams) {\n      this.queryParams = queryParams || {};\n    }\n    $$route$recognizer$$RecognizeResults.prototype = $$route$recognizer$$oCreate({\n      splice: Array.prototype.splice,\n      slice:  Array.prototype.slice,\n      push:   Array.prototype.push,\n      length: 0,\n      queryParams: null\n    });\n\n    function $$route$recognizer$$findHandler(state, path, queryParams) {\n      var handlers = state.handlers, regex = state.regex;\n      var captures = path.match(regex), currentCapture = 1;\n      var result = new $$route$recognizer$$RecognizeResults(queryParams);\n\n      result.length = handlers.length;\n\n      for (var i=0; i<handlers.length; i++) {\n        var handler = handlers[i], names = handler.names, params = {};\n\n        for (var j=0; j<names.length; j++) {\n          params[names[j]] = captures[currentCapture++];\n        }\n\n        result[i] = { handler: handler.handler, params: params, isDynamic: !!names.length };\n      }\n\n      return result;\n    }\n\n    function $$route$recognizer$$decodeQueryParamPart(part) {\n      // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n      part = part.replace(/\\+/gm, '%20');\n      var result;\n      try {\n        result = decodeURIComponent(part);\n      } catch(error) {result = '';}\n      return result;\n    }\n\n    // The main interface\n\n    var $$route$recognizer$$RouteRecognizer = function() {\n      this.rootState = new $$route$recognizer$$State();\n      this.names = {};\n    };\n\n\n    $$route$recognizer$$RouteRecognizer.prototype = {\n      add: function(routes, options) {\n        var currentState = this.rootState, regex = \"^\",\n            specificity = {},\n            handlers = new Array(routes.length), allSegments = [], name;\n\n        var isEmpty = true;\n\n        for (var i=0; i<routes.length; i++) {\n          var route = routes[i], names = [];\n\n          var segments = $$route$recognizer$$parse(route.path, names, specificity);\n\n          allSegments = allSegments.concat(segments);\n\n          for (var j=0; j<segments.length; j++) {\n            var segment = segments[j];\n\n            if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n            isEmpty = false;\n\n            // Add a \"/\" for the new segment\n            currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: \"/\" });\n            regex += \"/\";\n\n            // Add a representation of the segment to the NFA and regex\n            currentState = segment.eachChar(currentState);\n            regex += segment.regex();\n          }\n          var handler = { handler: route.handler, names: names };\n          handlers[i] = handler;\n        }\n\n        if (isEmpty) {\n          currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: \"/\" });\n          regex += \"/\";\n        }\n\n        currentState.handlers = handlers;\n        currentState.regex = new RegExp(regex + \"$\");\n        currentState.specificity = specificity;\n\n        if (name = options && options.as) {\n          this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n          };\n        }\n      },\n\n      handlersFor: function(name) {\n        var route = this.names[name];\n\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        var result = new Array(route.handlers.length);\n\n        for (var i=0; i<route.handlers.length; i++) {\n          result[i] = route.handlers[i];\n        }\n\n        return result;\n      },\n\n      hasRoute: function(name) {\n        return !!this.names[name];\n      },\n\n      generate: function(name, params) {\n        var route = this.names[name], output = \"\";\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        var segments = route.segments;\n\n        for (var i=0; i<segments.length; i++) {\n          var segment = segments[i];\n\n          if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n          output += \"/\";\n          output += segment.generate(params);\n        }\n\n        if (output.charAt(0) !== '/') { output = '/' + output; }\n\n        if (params && params.queryParams) {\n          output += this.generateQueryString(params.queryParams, route.handlers);\n        }\n\n        return output;\n      },\n\n      generateQueryString: function(params, handlers) {\n        var pairs = [];\n        var keys = [];\n        for(var key in params) {\n          if (params.hasOwnProperty(key)) {\n            keys.push(key);\n          }\n        }\n        keys.sort();\n        for (var i = 0; i < keys.length; i++) {\n          key = keys[i];\n          var value = params[key];\n          if (value == null) {\n            continue;\n          }\n          var pair = encodeURIComponent(key);\n          if ($$route$recognizer$$isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n              var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n              pairs.push(arrayPair);\n            }\n          } else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n          }\n        }\n\n        if (pairs.length === 0) { return ''; }\n\n        return \"?\" + pairs.join(\"&\");\n      },\n\n      parseQueryString: function(queryString) {\n        var pairs = queryString.split(\"&\"), queryParams = {};\n        for(var i=0; i < pairs.length; i++) {\n          var pair      = pairs[i].split('='),\n              key       = $$route$recognizer$$decodeQueryParamPart(pair[0]),\n              keyLength = key.length,\n              isArray = false,\n              value;\n          if (pair.length === 1) {\n            value = 'true';\n          } else {\n            //Handle arrays\n            if (keyLength > 2 && key.slice(keyLength -2) === '[]') {\n              isArray = true;\n              key = key.slice(0, keyLength - 2);\n              if(!queryParams[key]) {\n                queryParams[key] = [];\n              }\n            }\n            value = pair[1] ? $$route$recognizer$$decodeQueryParamPart(pair[1]) : '';\n          }\n          if (isArray) {\n            queryParams[key].push(value);\n          } else {\n            queryParams[key] = value;\n          }\n        }\n        return queryParams;\n      },\n\n      recognize: function(path) {\n        var states = [ this.rootState ],\n            pathLen, i, l, queryStart, queryParams = {},\n            isSlashDropped = false;\n\n        queryStart = path.indexOf('?');\n        if (queryStart !== -1) {\n          var queryString = path.substr(queryStart + 1, path.length);\n          path = path.substr(0, queryStart);\n          queryParams = this.parseQueryString(queryString);\n        }\n\n        path = decodeURI(path);\n\n        if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n\n        pathLen = path.length;\n        if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n          path = path.substr(0, pathLen - 1);\n          isSlashDropped = true;\n        }\n\n        for (i=0; i<path.length; i++) {\n          states = $$route$recognizer$$recognizeChar(states, path.charAt(i));\n          if (!states.length) { break; }\n        }\n\n        var solutions = [];\n        for (i=0; i<states.length; i++) {\n          if (states[i].handlers) { solutions.push(states[i]); }\n        }\n\n        states = $$route$recognizer$$sortSolutions(solutions);\n\n        var state = solutions[0];\n\n        if (state && state.handlers) {\n          // if a trailing slash was dropped and a star segment is the last segment\n          // specified, put the trailing slash back\n          if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n            path = path + \"/\";\n          }\n          return $$route$recognizer$$findHandler(state, path, queryParams);\n        }\n      }\n    };\n\n    $$route$recognizer$$RouteRecognizer.prototype.map = $$route$recognizer$dsl$$default;\n\n    $$route$recognizer$$RouteRecognizer.VERSION = '0.1.11';\n\n    var $$route$recognizer$$default = $$route$recognizer$$RouteRecognizer;\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define('route-recognizer', function() { return $$route$recognizer$$default; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = $$route$recognizer$$default;\n    } else if (typeof this !== 'undefined') {\n      this['RouteRecognizer'] = $$route$recognizer$$default;\n    }\n}).call(this);\n\n//# sourceMappingURL=route-recognizer.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/route-recognizer/dist/route-recognizer.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/buildin/module.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/buildin/amd-define.js\n ** module id = 5\n ** module chunks = 0\n **/","import { resolvePath } from '../util'\n\nexport default class AbstractHistory {\n    constructor ({onChange}) {\n        this.onChange = onChange\n        this.currentPath = '/'\n    }\n\n    start () {\n        this.onChange('/')\n    }\n\n    stop () {\n        // nothing to do\n    }\n\n    go (path, replace, append) {\n        path = this.currentPath = this.formatPath(path, append)\n        this.onChange(path)\n    }\n\n    formatPath (path, append) {\n        return path.charAt(0) === '/'? path : resolvePath(this.currentPath, path, append)\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/history/abstract.js\n **/","import {resolvePath} from '../util.js'\nconst hashRegExp = /#.*$/\n\nexport default class HTML5History {\n    constructor ({root,onChange}) {\n        if(root && root !== '/'){\n            // make sure the startting\n            if(root.charAt(0) !== '/'){\n                root = '/' + root\n            }\n            // remove trailing\n            this.root = root.replace(/\\/$/,'')\n            this.rootRegExp = new RegExp('^\\\\'+this.root)\n        } else {\n            this.root = null\n        }\n        this.onChange = onChange\n        // check the base\n        const baseEl = document.querySelector('base')\n        this.base = baseEl && baseEl.getAttribute('href')\n    }\n\n    start () {\n        this.listener = e => {\n            let url = location.pathname + location.search\n            if (this.root) {\n                url = url.replace(this.rootRegExp,'') || '/'\n            }\n            this.onChange(url, e && e.state, location.hash)\n        }\n        window.addEventListener('popstate', this.listener)\n        this.listener()\n    }\n\n    stop () {\n        window.removeEventListener('popstate', this.listener)\n    }\n\n    go (path, replace, append) {\n        const url = this.formatPath(path, append)\n        if (replace) {\n            history.replaceState({}, '', url)\n        } else {\n            // record scroll position by replacing current state\n            history.replaceState({\n                pos: {\n                    x:window.pageXOffset,\n                    y:window.pageYOffset,\n                }\n            },'',location.href)\n            // then push new state\n            history.pushState({}, '', url)\n        }\n\n        const hashMatch = path.match(hashRegExp)\n        const hash = hashMatch && hashMatch[0]\n        path = url\n            // strip hash so it doesn't mess up params\n            .replace(hashRegExp, '')\n            // remove root before matching\n            .replace(this.rootRegExp, '')\n        this.onChange(path, null, hash)\n    }\n\n    formatPath (path, append) {\n        return path.charAt(0) === '/'\n            ? this.root\n                ? this.root +'/' + path.replace(/^\\//,'')\n                : path\n            : resolvePath(this.base || location.pathname, path, append)\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/history/html5.js\n **/","(function() {(function (root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  }\n  else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  else {\n    var globalAlias = '__0';\n    var namespace = globalAlias.split('.');\n    var parent = root;\n    for ( var i = 0; i < namespace.length-1; i++ ) {\n      if ( parent[namespace[i]] === undefined ) parent[namespace[i]] = {};\n      parent = parent[namespace[i]];\n    }\n    parent[namespace[namespace.length-1]] = factory();\n  }\n}(this, function() {\n  function _requireDep(name) {\n    return {}[name];\n  }\n\n  var _bundleExports = undefined;NovaExports.__fixedUglify=\"script>\";NovaExports.exports={\"template\":\"\\n    \"};\n        NovaExports({\n            is: 'router-view',\n            props: {\n                content: {\n                    type: String,\n                    value: ''\n                },\n            },\n            createdHandler: function() {\n            },\n            attachedHandler: function() {\n            },\n            detachedHandler: function() { \n            },\n            attributeChangedHandler: function(attrName, oldVal, newVal) { \n            },\n        });\n    \n\n  return _bundleExports;\n}));}).call(window)\n\n\n/** WEBPACK FOOTER **\n ** ../src/component/router-view/main.js\n **/","const internalKeysRegExp = /^(component|subRoutes|fullPath)$/\nexport default class Route {\n    constructor (path,router){\n        const matched = router._recognizer.recognize(path)\n        if(matched) {\n            [].forEach.call(matched,match=>{\n                for(let key in match.handler){\n                    if(!internalKeysRegExp.test(key)) {\n                        this[key] = match.handler[key]\n                    }\n                }\n            })\n            // set query and params\n            this.query = matched.queryParams\n            this.params = [].reduce.call(matched, (prev,cur)=>{\n                if(cur.params){\n                    for (let key in cur.params){\n                        prev[key] =  cur.params[key]\n                    }\n                }\n                return prev\n            },{})\n        }\n\n        this.path = path\n        // set some property for internal use\n        this.matched = matched || router._notFoundHanlder\n        Object.defineProperty(this, 'router', {\n            enumeralbe:false,\n            value:router\n        })\n        Object.freeze(this)\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/route.js\n **/","import {\n    warn,\n    mapParams,\n    isPromise\n} from './util'\n\nimport {\n    deactivate,\n    activate,\n    canDeactivate,\n    canActivate,\n    getReuseQueue,\n} from './pipeline.js'\n\nexport default class Transition {\n    constructor (router, to, from){\n        this.router = router\n        this.to = to\n        this.from = from\n        this.next = null\n        this.aborted = false\n        this.done = false\n    }\n\n    /**\n     * abort current transition and return to previous location\n     * @return {[type]} [description]\n     */\n    abort(){\n        if(!this.aborted){\n            this.aborted = true\n            // 防止根路径加载失败时候的无限循环\n            const abortingOnLoad = !this.from.path && this.to.path === '/'\n            if(!abortingOnLoad) {\n                this.router.replace(this.from.path || '/');\n            }\n        }\n    }\n\n    /**\n     * abort current transition and go to the new path\n     * path can be string or object\n     * @param  {[type]} path [description]\n     * @return {[type]}      [description]\n     */\n    redirect (path) {\n        if(!this.aborted){\n            this.aborted = true\n            if(typeof path === 'string'){\n                path = mapParams(path, this.to.params, this.to.query)\n            } else {\n                path.params = path.params || this.to.params\n                path.query = path.query || this.to.query\n            }\n            this.router.replace(path)\n        }\n    }\n\n    /**\n     * 开始一次转换\n     * @param  {Function} cb [description]\n     * @return {[type]}      [description]\n     */\n    start(cb=(()=>{})){\n        const transition = this\n\n        let deactivateQueue = this.from.matched\n        ? [].map.call(this.from.matched,each=>{\n            return each;\n        })\n        : [];\n        let activateQueue = this.to.matched\n        ? [].map.call(this.to.matched,each=>{\n            return each;\n        })\n        : [];\n        let reverseDeactivateQueue = deactivateQueue.slice().reverse()\n\n        // 获取重用队列\n        transition.reuseQueue = getReuseQueue(deactivateQueue,activateQueue,this)\n        \n\n        // 此处有一个检测是否可以重用的部分\n        transition.runQueue(reverseDeactivateQueue,canDeactivate,{factor:1},()=>{\n            transition.runQueue(activateQueue,canActivate,{factor:-1},()=>{\n                // now we validate it can run\n                // so i inform the router that i start a new transition\n                transition.router._onTransitionValidated(transition)\n                transition.runQueue(reverseDeactivateQueue,deactivate,{factor:1},()=>{\n                    transition.runQueue(activateQueue,activate,{factor:-1},cb)\n                })\n            })\n        })\n    }\n    /**\n     * 递归执行队列里要求的函数\n     * @param  {[type]}   queue [description]\n     * @param  {Function} fn    [description]\n     * @param  {Function} cb    [description]\n     * @return {[type]}         [description]\n     */\n    runQueue(queue, fn, {factor=0,start=0, end=queue.length,fnArgs=[]}, cb=(()=>{})){\n        const transition = this;\n        step(start)\n        function step (index) {\n            if(index >= end){\n                cb()\n            } else {\n                let Args\n                if(!factor){\n                    Args = [queue[index]]\n                } else {\n                    Args = [queue[index+factor],queue[index]]\n                }\n                Args = Args.concat([transition,()=>{\n                    step(index+1)\n                }]).concat(fnArgs)\n                // console.log(fn,Args)\n                fn.apply(transition,Args)\n            }\n        }\n    }\n\n    /**\n     * 调用钩子函数专用\n     * @param  {[type]}   hook                  [description]\n     * @param  {[type]}   context               [description]\n     * @param  {Function} cb                    [description]\n     * @param  {Boolean}  options.expectBoolean [description]\n     * @param  {Boolean}  options.postActivate  [description]\n     * @param  {[type]}   options.processData   [description]\n     * @param  {Object}   options.cleanup                       } [description]\n     * @return {[type]}                         [description]\n     */\n    callHook (hook, context, cb, {\n        expectBoolean = false,\n        postActivate = false, // 必定触发激活\n        processData,\n        cleanup\n    }={}){\n        const transition = this;\n        let nextCalled = false;\n        let aborted = false\n\n        // abort the transition\n        const abort = ()=>{\n            aborted = true\n            cleanup && cleanup()\n            transition.abort()\n        }\n\n        // handle errors\n        const onError = err=>{\n            postActivate? next():abort()\n            if(err && !transition.router._suppress){\n                warn('Uncaught error during transition: ')\n                throw err instanceof Error ? err : new Error(err)\n            }\n        }\n\n        // promise will swallows errors?\n        // it seems i use resolve can sovle this problem\n        // but resolve means wrap a new promise=--=\n        // let me do a test\n        const onPromiseError = err=>{\n            try {\n                onError(err)\n            } catch (e) {\n                setTimeout(() => {throw e},0)\n            }\n        }\n        // 没有返回的下一步\n        const next = ()=>{\n            if(nextCalled) {\n                warn('transition.next() should be called only once.')\n                return\n            }\n            nextCalled = true\n            if(transition.aborted) {\n                cleanup && cleanup()\n                return\n            }\n            cb && cb()\n        }\n\n        // 需要处理正确错误的下一步\n        const nextWithBoolean = res=>{\n            if(typeof res === 'boolean'){\n                res ? next() : abort()\n            } else if (isPromise(res)){\n                res.then((ok) => {\n                    ok ? next() : abort()\n                },onPromiseError)\n            } else if(!hook.length) { // 如果没有参数\n                onError(\"must return Boolean or Promise in \"+ hook)\n            }\n            \n        }\n\n        // 需要处理数据的下一步\n        const nextWithData = data =>{\n            let res\n            try {\n                res = processData(data)\n            } catch (err) {\n                return onError(err)\n            }\n            if(isPromise(res)) {\n                res.then(next, onPromiseError)\n            } else {\n                next()\n            }\n        }\n\n        // expose a clone of transition so that would not mix up\n        const exposed = {\n            to: transition.to,\n            from: transition.from,\n            abort:postActivate?(()=>true):abort,\n            next:processData ? nextWithData : next,\n            redirect: function(){\n                transition.redirect.apply(transition,arguments)\n            }\n        }\n\n        // actually call the hook\n        let res\n        try {\n            res = hook.call(context,exposed)\n        } catch (err){\n            return onError(err)\n        }\n        if(expectBoolean) {\n            nextWithBoolean(res)\n        } else if(isPromise(res)) {\n            if(processData){\n                res.then(nextWithData, onPromiseError)\n            } else {\n                res.then(next, onPromiseError)\n            }\n        } else if (processData && isPlainOjbect(res)){\n            nextWithData(res)\n        } else if (!hook.length) {\n            // 没有传入参数的情况下\n            next()\n        }\n    }\n\n    /**\n     * call single hook or array of hooks\n     * @param  {[type]}   hooks   [description]\n     * @param  {[type]}   context [description]\n     * @param  {Function} cb      [description]\n     * @param  {[type]}   options [description]\n     * @return {[type]}           [description]\n     */\n    callHooks (hooks,context,cb,options) {\n        if(Array.isArray(hooks)){\n            this.runQueue(hooks,(hook, transition, next) => {\n                if(!this.aborted) {\n                    this.callHook(hook,context,next,options)\n                }\n            },{},cb)\n        } else {\n            this.callHook(hooks,context,cb,options)\n        }\n    }\n}\n\nfunction isPlainOjbect (val) {\n    return Object.prototype.toString.call(val) === '[object Object]'\n}\n\nfunction toArray (val) {\n    return val? Array.prototype.slice.call(val): []\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/transition.js\n **/","import {\n  isPromise,\n} from './util'\n\nexport function getReuseQueue (deactivateQueue,activateQueue,transition) {\n    let depth = Math.min(deactivateQueue.length,activateQueue.length)\n    let reuseQueue = [];\n    for(let i=0;i<depth;i++){\n        let deactivateComponent = deactivateQueue[i].handler.component\n        let activateComponent = activateQueue[i].handler.component\n        if(Object.is(deactivateComponent,activateComponent)){\n            let canComponentReuse = deactivateComponent.route \n            ? typeof deactivateComponent.route.canReuse === 'function' \n                ? deactivateComponent.route.canReuse({to:transition.to,from:transition.from})\n                : deactivateComponent.route.canReuse\n            : true\n            if(canComponentReuse === false){\n                i--;\n                break;\n            }\n            reuseQueue.push(deactivateQueue[i])\n        } else {\n            i--;\n            break;\n        }\n    }\n    return reuseQueue;\n}\n\nexport function deactivate (parent, child, transition, cb){\n    parent = parent || {handler:{component:transition.router.routerView}}\n    if(isChildNode(parent.handler.component,child.handler.component)){\n        if(canReuse(child,transition)){\n            cb && cb && cb()\n            return\n        }\n        let component = child.handler.component\n        let fn = (component.route && component.route.deactivate) || (()=>true)\n        transition.callHook(fn,component,()=>{\n            parent.handler.component.removeChild(child.handler.component)\n            cb && cb()\n        },{postActivate:true})\n    } else {\n        cb && cb && cb()\n    }\n}\n\nexport function activate (parent, child, transition, cb){\n    parent = parent || {handler:{component:transition.router.routerView}}\n    let component = child.handler.component\n    // component.$route = {\n    //     path:transition.router._currentRoute.path,\n    //     params:transition.router._currentRoute.params,\n    //     query:transition.router._currentRoute.query,\n    // }\n    // console.log(component.$route)\n    if(!isChildNode(parent.handler.component,child.handler.component)){\n        let fn = (component.route && component.route.activate) || (()=>true)\n        transition.callHook(fn,component,()=>{\n            parent.handler.component.appendChild(child.handler.component)\n            data(component,transition)\n            cb && cb()\n        },{postActivate:true})\n    } else {\n        data(component,transition)\n        cb && cb()\n    }\n}\n\nexport function canActivate(parent,child,transition,cb){\n    parent = parent || {handler:{component:transition.router.routerView}}\n    if(!isChildNode(parent.handler.component,child.handler.component)){\n        let component = child.handler.component\n        let fn = (component.route && component.route.canActivate) || (()=>true)\n        transition.callHook(fn,component,cb,{expectBoolean:true});\n    } else {\n        cb && cb()\n    }\n}\n\nexport function canDeactivate(parent,child,transition,cb){\n    parent = parent || {handler:{component:transition.router.routerView}}\n    if(parent.handler.component.contains(child.handler.component)){\n        if(canReuse(child,transition)){\n            cb && cb();\n            return \n        }\n        let component = child.handler.component\n        let fn = (component.route && component.route.canDeactivate) || (()=>true)\n        transition.callHook(fn,component,cb,{expectBoolean:true});\n    } else {\n        cb && cb()\n    }\n        \n}\n\nexport function canReuse(child,transition){\n    for(let i= transition.reuseQueue.length-1;i>-1;i--){\n        if(Object.is(child.handler.component,transition.reuseQueue[i].handler.component)){\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function data(component,transition){\n    component.loadingRouteData = true;\n    let fn = (component.route && component.route.data) || (()=>{return {}})\n    transition.callHook(fn,component,()=>{\n        component.loadingRouteData = false;\n    },{\n        postActivate:true,\n        // 处理data语法糖\n        processData: data=>{\n            const promises = []\n            if(isPlainObject(data)){\n                Object.keys(data).forEach(key => {\n                    const val = data[key]\n                    if(isPromise(val)) {\n                        promises.push(val.then(resolvedData=>{\n                            component[key] = resolvedData\n                        }))\n                    } else {\n                        component[key] = val\n                    }\n                })\n            }\n            if(promises.length) {\n                return promises[0].constructor.all(promises)\n            }\n        }\n    })\n}\n\nexport function isChildNode(parent,child){\n    if(!parent || !child || !parent.hasChildNodes()){\n        return false\n    }\n    let nodes = parent.childNodes\n    for(let i=nodes.length-1;i>-1;i--){\n        if(nodes[i].isSameNode(child)){\n            return true\n        }\n    }\n    return false\n}\n\n/**\n * Check plain object.\n *\n * @param {*} val\n */\n\nfunction isPlainObject (val) {\n    return Object.prototype.toString.call(val) === '[object Object]'\n}\n\n\n/** WEBPACK FOOTER **\n ** ../src/pipeline.js\n **/"],"sourceRoot":""}